// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");
var Test$LearnReasonmlWorkshop = require("../../support/test.bs.js");

var ints = /* :: */[
  1,
  /* :: */[
    2,
    /* :: */[
      3,
      /* [] */0
    ]
  ]
];

var sumOfMyInts = List.fold_left((function (total, myInt) {
        return total + myInt | 0;
      }), 0, ints);

if (6 !== sumOfMyInts) {
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "writingListOperations.re",
          27,
          9
        ]
      ];
}

function map(f, lst) {
  return Pervasives.failwith("For you to implement");
}

function iter(f, lst) {
  return Pervasives.failwith("For you to implement");
}

function filter(f, lst) {
  return Pervasives.failwith("For you to implement");
}

var MyList = {
  map: map,
  iter: iter,
  filter: filter
};

if (List.hd(/* :: */[
        1,
        /* :: */[
          2,
          /* :: */[
            3,
            /* [] */0
          ]
        ]
      ]) !== 1) {
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "writingListOperations.re",
          68,
          9
        ]
      ];
}

if (!Caml_obj.caml_equal(List.tl(/* :: */[
            1,
            /* :: */[
              2,
              /* :: */[
                3,
                /* [] */0
              ]
            ]
          ]), /* :: */[
        2,
        /* :: */[
          3,
          /* [] */0
        ]
      ])) {
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "writingListOperations.re",
          76,
          9
        ]
      ];
}

if (!Caml_obj.caml_equal(List.rev(/* :: */[
            1,
            /* :: */[
              2,
              /* :: */[
                3,
                /* [] */0
              ]
            ]
          ]), /* :: */[
        3,
        /* :: */[
          2,
          /* :: */[
            1,
            /* [] */0
          ]
        ]
      ])) {
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "writingListOperations.re",
          83,
          9
        ]
      ];
}

if (!List.mem(3, /* :: */[
        1,
        /* :: */[
          2,
          /* :: */[
            3,
            /* [] */0
          ]
        ]
      ])) {
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "writingListOperations.re",
          91,
          9
        ]
      ];
}

if (!Caml_obj.caml_equal(List.sort((function (x, y) {
              return x - y | 0;
            }), /* :: */[
            3,
            /* :: */[
              1,
              /* :: */[
                2,
                /* [] */0
              ]
            ]
          ]), /* :: */[
        1,
        /* :: */[
          2,
          /* :: */[
            3,
            /* [] */0
          ]
        ]
      ])) {
  throw [
        Caml_builtin_exceptions.assert_failure,
        /* tuple */[
          "writingListOperations.re",
          101,
          9
        ]
      ];
}

var acc = {
  contents: 0
};

Pervasives.failwith("For you to implement");

Test$LearnReasonmlWorkshop.runAll(/* :: */[
      /* tuple */[
        Caml_obj.caml_equal(Pervasives.failwith("For you to implement"), /* :: */[
              2,
              /* :: */[
                4,
                /* :: */[
                  6,
                  /* :: */[
                    8,
                    /* [] */0
                  ]
                ]
              ]
            ]),
        "MyList.map"
      ],
      /* :: */[
        /* tuple */[
          acc.contents === 8,
          "MyList.iter"
        ],
        /* :: */[
          /* tuple */[
            Caml_obj.caml_equal(Pervasives.failwith("For you to implement"), /* :: */[
                  8,
                  /* :: */[
                    2,
                    /* [] */0
                  ]
                ]),
            "MyList.filter"
          ],
          /* [] */0
        ]
      ]
    ]);

exports.ints = ints;
exports.sumOfMyInts = sumOfMyInts;
exports.MyList = MyList;
exports.acc = acc;
/* sumOfMyInts Not a pure module */
